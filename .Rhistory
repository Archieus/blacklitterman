names(TDYlds)
names(TDYlds[2])
names(TDYlds[8])
View(TDYlds)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- col.names(TDYlds[2:8])
print(Spreads)
colnames(Spreads) <- colnames(TDYlds[2:8])
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
View(TDYlds)
TDYlds
TDYlds<-   read.table("yields.txt", header = TRUE, sep = '\tX') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields, function(x) as.numeric(as.character(x)))))
Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- Yields[,i] - TsyYlds[,i]
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Spreads)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
naming <- gsub(TDYlds, "X","")
View(TDYlds)
?read.table
TDYlds<-   read.table("yields.txt", header = TRUE, col.names = header, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
TDYlds<-   read.table("yields.txt", header = TRUE, col.names = "", sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
TDYlds<-   read.table("yields.txt", header = TRUE, col.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
TDYlds<-   read.table("yields.txt", header = TRUE, col.names = NULL, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
TDYlds<-   read.table("yields.txt", header = FALSE, sep = '\t') #sep = "tab delimited"
View(TDYlds)
TDYlds<-   read.table("yields.txt", header = TRUE, sep = '\t') #sep = "tab delimited"
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
Yields[1:10]
Yields(1:10)
Yields[,1:10]
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
View(Yields)
View(TDYlds)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
#Yields <- TDYlds[,2:8]
#row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(TDYlds, function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (Yields[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(TDYlds)
print(Spreads)
source('C:/Users/rodney/Dropbox/RCode/Test Files/Fixed Income/YieldGrid.R', echo=TRUE)
Yields <- TDYlds[,2:8]
#row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields, function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (Yields[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Yields)
print(Spreads)
View(TDYlds)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
#Yields <- TDYlds[,2:8]
#row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(TDYlds, function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (Yields[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Yields)
print(Spreads)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(TDYlds, function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (Yields[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Yields)
print(Spreads)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(TDYlds, function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (TDYlds[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Yields)
print(Spreads)
View(TDYlds)
View(Yields)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
View(TDYlds)
Yields <- TDYlds[,2:8]
View(Yields)
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(TDYlds, function(x) as.numeric(as.character(x)))))
View(Yields)
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields, function(x) as.numeric(as.character(x)))))
View(Yields)
Yields
View(Yields)
View(TDYlds)
View(Yields)
suppressWarnings(Yields <- as.data.frame(lapply(Yields[,], function(x) as.numeric(as.character(x)))))
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
suppressWarnings(Yields <- as.data.frame(lapply(Yields[], function(x) as.numeric(as.character(x)))))
View(Yields)
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields[], function(x) as.numeric(as.character(x)))))
#Yields[is.na(Yields)] <- 0 ## Turn NAs to 0
row.names(Yields) <- TDYlds[,1]
TsyYlds <- Yields[11,]
Spreads <- matrix(0, nrow = 11, ncol = 7)
for(i in 1:7) {
Spreads[,i] <- (TDYlds[,i] - TsyYlds[,i])
}
row.names(Spreads) <- TDYlds[,1]
colnames(Spreads) <- colnames(TDYlds[2:8])
print(Yields)
print(Spreads)
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields[], function(x) as.numeric(as.character(x)))))
TDYlds<-   read.table("yields.txt", header = TRUE, check.names = FALSE, sep = '\t') #sep = "tab delimited"
Yields <- TDYlds[,2:8]
row.names(Yields) <- TDYlds[,1]
#### Convert Non-Numeric to NA ####
suppressWarnings(Yields <- as.data.frame(lapply(Yields[], function(x) as.numeric(as.character(x)))))
RandomNumbers <- runif(100, 1, 100)
RandomNumber2 <- runif(100, 1, 100)
plot(RandomNumbers)
par(new = TRUE)
plot(RandomNumber2)
plot(RandomNumber2, type = 'l')
par(new = TRUE)
plot(RandomNumbers)
install.packages(c("lubridate", "openssl", "rlang", "Rsymphony", "tidyselect"))
install.packages("C:/Users/rodney/Downloads/Rsymphony_0.1-27.zip", repos = NULL, type = "win.binary")
install.packages("C:/Users/rodney/Downloads/Rsymphony_0.1-28.tar.gz", repos = NULL, type = "source")
library(RCurl)
# library(data.table)
ETH <- getURL('https://etherchain.org/api/statistics/price')
install.packages("rvest")
library(rvest)
url <- 'http://www.barrons.com/public/page/9_0210-wyldgp.html'
#Reading the HTML code from the website
webpage <- read_html(url)
str(webpage)
webpage$node
webpage$doc
setwd("~/")
read.table("~/BarronsConfidence.txt", sep = "")
read.table("~/BarronsConfidence.txt, sep = """)
read.table("~/BarronsConfidence.txt, sep = " "")
read.table("~/BarronsConfidence.txt")
read.table("~/BarronsConfidence.txt", sep = ",")
read.table("~/BarronsConfidence.txt", sep = "\")
read.table("~/BarronsConfidence.txt", sep = "\t")
read.table("~/BarronsConfidence.txt", sep = "\\t")
read.table("~/BarronsConfidence.txt", sep = "\\")
read.table("~/BarronsConfidence.txt", sep = ",")
read.table("~/BarronsConfidence.txt", sep = " ")
read.table("~/BarronsConfidence.txt", sep = "\t")
read.table("~/BarronsConfidence.txt", sep = "\\t")
read.table("~/BarronsConfidence.txt", sep = "/\t")
test <- read.table("~/BarronsConfidence.txt", sep = "\\t")
test <- read.table("~/BarronsConfidence.txt", sep = "\t")
test <- read.table("~/BarronsConfidence.txt", sep = "/t")
test <- read.table("~/BarronsConfidence.txt", sep = "\t")
test <- read.table("~/BarronsConfidence.txt")
test <- read.table("~/BarronsConfidence.txt", sep ="\t")
setwd("~/")
test <- read.table("~/BarronsConfidence.txt", sep ="\t")
scan("~/BarronsConfidence.txt")
test <- read.table("~/BarronsConfidence.txt", sep =",")
View(test)
colno <- max(count.fields("~/BarronsConfidence.txt", sep = ','))
test <- as.data.frame(read.table("~/BarronsConfidence.txt", sep =","))
test <- as.data.frame(read.table("~/BarronsConfidence.txt", sep ="\"))
)
)
test <-read.table("~/BarronsConfidence.txt", sep ="\")
test <-read.table("~/BarronsConfidence.txt", sep ="\\")
View(test)
test <-read.table("~/BarronsConfidence.txt", sep = c("\\", "\\t"))
test <-read.table("~/BarronsConfidence.txt", sep = "\\t")
test <-read.table("~/BarronsConfidence.txt", sep = c("\\t"))
test <-read.table("~/BarronsConfidence.txt", sep = c("\\", "t"))
setwd("~/")
read.table("BarronsConfidence.txt", sep = "\t", dec = ".", header = TRUE, encoding = "UTF-8", stringsAsFactors = FALSE, quote = "")
read.table("BarronsConfidence.txt", sep = "/t", dec = ".", header = TRUE, encoding = "UTF-8", stringsAsFactors = FALSE, quote = "")
read.table("BarronsConfidence.txt", sep = "\\t", dec = ".", header = TRUE, encoding = "UTF-8", stringsAsFactors = FALSE, quote = "")
source('~/.active-rstudio-document', echo=TRUE)
last(BEER)
library(quantmod)
Sys.setenv(TZ = "UTC")
#1. Avg Annual Hourly Earnings All Employees Total Private = CES0500000003
#2. Employed FT median Usual Weekly Real Earnings: Wages and Salasy 16Years and Older = LES1252881600Q
###Correlates best with quarterly Core Inflation Data "ECIWAG"###
#3. Employment Cost Index Wages and Salaries Private industry Workers = ECIWAG
#4. Employer Cost for Emplyee Compensation = Not Available on FRED
#5. Compensation per hour Nonfarm Business Sector: Unit Labor Costs = ULCNFB
#6. Unit Labor Costs = ULCNFB
wagedata <- c("CES0500000003", "LES1252881600Q", "ECIWAG", "ULCNFB")
suppressWarnings(getSymbols(wagedata, src = 'FRED', from = "1997-05-01"))
View(CES0500000003)
View(ECIWAG)
View(LES1252881600Q)
View(ULCNFB)
?getSymbols
?to.period
to.quarterly(CES0500000003,indexAt='yearqtr',drop.time=TRUE)
to.quarterly(CES0500000003,indexAt='yearmon',drop.time=TRUE)
to.quarterly(CES0500000003,indexAt='firstof',drop.time=TRUE)
to.quarterly(CES0500000003,indexAt='startof',drop.time=TRUE)
HourlyEarnings <- to.quarterly(CES0500000003,indexAt='startof',drop.time=TRUE)[,4]
View(HourlyEarnings)
layout(rbind(c(1,2), c(3,4)))
plot(ECIWAG)
plot(HourlyEarnings)
plot(LES1252881600Q)
plot(ULCNFB)
layout(rbind(c(1,2), c(3,4)))
plot(ECIWAG, main  = "Employment Cost Index")
plot(HourlyEarnings, main = "Hourly Earnings")
plot(LES1252881600Q, main = "Real Earnings & Salaries")
plot(ULCNFB, main = "Unit Labor Costs")
ECI.ROC <- na.omit(ROC(ECIWAG,4))
plot(ECI.ROC)
####1-Year ROC####
ECI.ROC <- na.omit(ROC(ECIWAG,4))
HrEa.ROC <- na.omit(ROC(HourlyEarnings,4))
RealES.ROC <- na.omit(ROC(LES1252881600Q,4))
ULC.ROC <- na.omit(ROCULCNFB,4))
####1-Year ROC####
ECI.ROC <- na.omit(ROC(ECIWAG,4))
HrEa.ROC <- na.omit(ROC(HourlyEarnings,4))
RealES.ROC <- na.omit(ROC(LES1252881600Q,4))
ULC.ROC <- na.omit(ROC(ULCNFB,4))
layout(rbind(c(1,2), c(3,4)))
plot(ECI.ROC, main  = "Employment Cost Index 1-Yr ROC")
plot(HrEa.ROC, main = "Hourly Earnings 1-Yr ROC")
plot(RealES.ROC, main = "Real Earnings & Salaries 1-Yr ROC")
plot(ULC.ROC, main = "Unit Labor Costs 1-Yr ROC")
layout(rbind(c(1,2), c(3,4)))
plot(ECIWAG, main  = "Employment Cost Index")
plot(HourlyEarnings, main = "Hourly Earnings")
plot(LES1252881600Q, main = "Real Earnings & Salaries")
plot(ULCNFB, main = "Unit Labor Costs")
layout(rbind(c(1,2), c(3,4)))
plot(ECI.ROC['2009:/'], main  = "Employment Cost Index 1-Yr ROC")
plot(HrEa.ROC['2009:/'], main = "Hourly Earnings 1-Yr ROC")
plot(RealES.ROC['2009:/'], main = "Real Earnings & Salaries 1-Yr ROC")
plot(ULC.ROC['2009:/'], main = "Unit Labor Costs 1-Yr ROC")
# Cleaning the workspace
rm(list=ls())
# RQuantLib loading
suppressPackageStartupMessages(library(RQuantLib))
# ESGtoolkit loading
suppressPackageStartupMessages(library(ESGtoolkit))
install.packages("ESGtoolkit")
source('~/.active-rstudio-document', echo=TRUE)
650*.08625
649.91*.08625
649.91
649.91+56.05
594.12*1.08625
705.96-645.36
330.82-311.88
18.94/330.82
220.32-214.47
5.85/220.32
8000/500
859664/2
429677*.05
21483.85/68.04
429677*.0380
16327.73/30
q()
setwd("C:/RPrograms/BlackLitterman")
source('C:/RPrograms/BlackLitterman/BLModel.R', echo=TRUE)
?Return.excess
RiskPrem <- Return.excess(Ret.mo$AGG, rf = .029/12)
RiskPrem <- Return.excess(Ret.mo$AGG, Rf = .029/12)
View(RiskPrem)
source('C:/RPrograms/BlackLitterman/BLETFB.R', echo=TRUE)
View(RiskPrem)
setwd("C:/Users/rodney/Dropbox/RCode/2. Equity Market Indicators/MeanRev_Trend_Rotation")
source('C:/Users/rodney/Dropbox/RCode/2. Equity Market Indicators/MeanRev_Trend_Rotation/NDRStrengthOfTrend.R', echo=TRUE)
setwd("C:/RPrograms/BlackLitterman")
source('C:/RPrograms/BlackLitterman/BLETFB.R', echo=TRUE)
View(RiskPrem)
View(ExcRet)
PremData <- na.omit(cbind(ExcRet,RiskPrem))
View(PremData)
RiskAver <- PremData[20]/PremData[1:19]
RiskAver <- PremData[,20]/PremData[,1:19]
RiskAver <- apply(PremData[20], function(x) x/PremData[1:19])
RiskAver <- apply(PremData[20], function(x) {x/PremData[1:19]})
?apply
RiskAver <- apply(PremData[20], 1, function(x) {x/PremData[1:19]})
RiskAver <- apply(RiskPrem, 1, function(x) {x/ExcRet})
RiskAver <- na.omit(apply(RiskPrem, 1, function(x) {x/ExcRet}))
RiskAver <- na.omit(lapply(RiskPrem, 1, function(x) {x/ExcRet}))
RiskAver <- na.omit(lapply(RiskPrem, function(x) {x/ExcRet}))
RiskAver <- na.omit(sapply(RiskPrem, function(x) {x/ExcRet}))
RiskAver <- na.omit(sapply(PremData[20], function(x) {x/PremData[1:19]}))
View(RiskAver)
RiskAver <- na.omit(sapply(PremData[,20], function(x) {x/PremData[,1:19]}))
RiskAver <- na.omit(lapply(PremData[,20], function(x) {x/PremData[,1:19]}))
RiskAver <- do.call(merge, lapply(PremData[,20], function(x) na.omit(x/PremData[,1:19])))
RiskAver <- sapply(PremData[,20]/PremData[,1:19])
RiskAver <- sapply(PremData[,20], function(x) x/PremData[,1:19])
RiskAver <- sapply(t(PremData[,20]), function(x) x/PremData[,1:19])
RiskAver <- lapply(PremData[,20], function(x) x/PremData[,1:19])
RiskAver <- lapply(PremData[,20], function(x) x %/%PremData[,1:19])
RiskAver <- sapply(PremData[,20], function(x) x %/%PremData[,1:19])
RiskAver <- sapply(t(PremData[,20]), function(x) x %/%PremData[,1:19])
sweep
?sweep
test <- PremData[20] %/% PremData[1:19]
View(test)
test <- PremData[,20] %/% PremData[,c(1:19)]
test <- PremData/PremData
test
test <- PremData[20]/PremData
View(test)
test <- PremData[20]/PremData[1:19]
test <- t(PremData[20])/PremData[1:19]
test <- PremData[20]/t(PremData[1:19])
length(PremData)
RiskAver <- matrix
for (i in 1:length(PremData)) {
RiskAver[,length(PremData)] <- PremData[20] / PremData[i]
}
nrow(PremData)
ncol(PremData)
RiskAver <- matrix(0, nrow = nrow(PremData), ncol = ncol(PremData))
for (i in 1:length(PremData)) {
RiskAver[i] <- PremData[20] / PremData[i]
}
for (i in 1:length(PremData)) {
RiskAver[,i] <- PremData[,20] / PremData[,i]
}
for (i in 1:length(PremData)) {
RiskAver[i] <- PremData[,20] / PremData[,i]
}
for (i in 1:ncol(PremData)) {
RiskAver[i] <- PremData[,20] / PremData[,i]
}
View(RiskAver)
PremData[,20]/PremData[,1]
-.0039345492/.0074185037
rowname(RiskAver) <- index(PremData)
rownames(RiskAver) <- index(PremData)
rownames(RiskAver) <- rownames(PremData)
RiskAv.df <- as.data.frame(RiskAver)
rownames(RiskAv.df) <- index(PremData)
View(RiskAv.df)
RiskAv.df <- as.data.frame(RiskAver[1:19])
RiskAv.df <- as.data.frame(RiskAver[,1:19])
rownames(RiskAv.df) <- index(PremData)
names(RiskAv.df) <- names(PremData[1:19])
names(RiskAv.df) <- colnames(PremData[1:19])
RiskAv.df <- as.data.frame(RiskAver)
rownames(RiskAv.df) <- index(PremData)
names(RiskAv.df) <- colnames(PremData)
RiskAv.x <- as.xts(RiskAv.df[,1:19])
View(RiskAv.x)
CAPMCov <- cov(RiskAv.x)
View(CAPMCov)
AltCAPMPost <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = CAPMCov)
##myPosterior Data##
priorMeans <- rep(0,19) #set means to 0 for the twelve assets
priorVarcov <- cov.mve(ExcRet)$cov
###Create a "pick" matrix.  Connects assets with a specific "view"
Pick <- matrix(0, ncol = ncol(priorVarcov), nrow = 6, dimnames = list(NULL,as.list(colnames(priorVarcov))))
###Create a Vector Q which contains information on the Excess Return for the corresponding "view"
QVect <- c(0,0,0,0,0,0)
##Fill Matrix with Picks on over and underperformance (Relative or Absolute)###
##Relative views in a row must net to zero (0).
##Absolute view in a row must add upt to one (1).
##Fill row1, col7 ==> pick[1,7]
Pick[1,1] <- 1
Pick[1,11] <- -1
# tau = scalar = set to as close to zero as possible (in practice) .025?
##Calculate the confidence of the Views (recipricols of the Variances of View Portfolios * tau)
ViewConf <- c(.01,.01,.01,.01,.01,.01) #Between .01(No confidence) and 100(High confidence)
Views <- BLViews(Pick, QVect, confidences = ViewConf, assetNames = colnames(priorVarcov))
###Generate "posterior" estimates using "prior" inputs and Investors Views and confidences
ExRetPosterior <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = priorVarcov)
CAPMPosterior <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = CovMat)
AltCAPMPost <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = CAPMCov)
optimalPortfolios(ExRetPosterior)
optimalPortfolios(CAPMPosterior)
#optimalPortfolios.fPort(myPosterior, constraints = 'maxW[1:12] = .2',optimizer = "minriskPortfolio", numSimulations = 100)
#write.csv(CAPMbeta, file = "ETFBeta.csv")
#write.csv(ERAnnl, file = "ETFExcRet.csv")
optimalPortfolios((AltCAPMPost))
source('C:/RPrograms/BlackLitterman/BLETFB.R', echo=TRUE)
?CAPM.beta
BetaCov <- BetaCoVariance(Ret.mo[,c(1:7,9:20)], Ret.mo$SPY)
View(BetaCov)
View(CAPMbeta)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(fPortfolio)
library(quantmod)
library(BLCOP)
#### Close data from TC2000 Convert TXT to XTS ####
ETFtxt <- read.table('etfb', header = FALSE, sep = ",")
ETFzoo <- read.zoo(ETFtxt, sep = ",", format = "%m/%d/%Y", split = 3)
ETFxts <- as.xts(ETFzoo)
ETFRet <- na.omit(Return.calculate(ETFxts))
View(ETFRet)
###Convert to Monthly Data
monthend <- endpoints(ETFRet, on = "months", k = 1)
Ret.mo <- ETFRet[monthend]
CAPMbeta <- CAPM.beta(Ret.mo[,c(1:8,10:21)], Ret.mo$SPY, .03/12)
CAPM.roll <- na.omit(rollapply(Ret.mo[,c(1:8,10:21)], 12, function(x) CAPM.beta(x, Ret.mo$SPY, .03/12)))
CovMat <- cov(CAPM.roll)
ExcRet <- Return.excess(Ret.mo[,c(1:8,10:21)], Ret.mo$SPY) #mu
ERAnnl <- Return.annualized.excess(Ret.mo[,c(1:8,10:21)], Ret.mo$SPY)
#ER.mu <- as.numeric(colMeans(ExcRet))
##myPosterior Data##
priorMeans <- rep(0,20) #set means to 0 for the twelve assets
priorVarcov <- cov.mve(ExcRet)$cov
###Create a "pick" matrix.  Connects assets with a specific "view"
Pick <- matrix(0, ncol = ncol(priorVarcov), nrow = 6, dimnames = list(NULL,as.list(colnames(priorVarcov))))
###Create a Vector Q which contains information on the Excess Return for the corresponding "view"
QVect <- c(0,0,0,0,0,0)
##Fill Matrix with Picks on over and underperformance (Relative or Absolute)###
##Relative views in a row must net to zero (0).
##Absolute view in a row must add upt to one (1).
##Fill row1, col7 ==> pick[1,7]
Pick[1,1] <- 1
Pick[1,11] <- -1
# tau = scalar = set to as close to zero as possible (in practice) .025?
##Calculate the confidence of the Views (recipricols of the Variances of View Portfolios * tau)
ViewConf <- c(.01,.01,.01,.01,.01,.01) #Between .01(No confidence) and 100(High confidence)
Views <- BLViews(Pick, QVect, confidences = ViewConf, assetNames = colnames(priorVarcov))
###Generate "posterior" estimates using "prior" inputs and Investors Views and confidences
ExRetPosterior <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = priorVarcov)
CAPMPosterior <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = CovMat)
#AltCAPMPost <- posteriorEst(Views, mu = priorMeans, tau = 0.025, sigma = CAPMCov)
optimalPortfolios(ExRetPosterior)
optimalPortfolios(CAPMPosterior)
#optimalPortfolios.fPort(myPosterior, constraints = 'maxW[1:12] = .2',optimizer = "minriskPortfolio", numSimulations = 100)
#write.csv(CAPMbeta, file = "ETFBeta.csv")
#write.csv(ERAnnl, file = "ETFExcRet.csv")
write.csv(CAPMbeta, file = "ETFBeta.csv")
write.csv(ERAnnl, file = "ETFExcRet.csv")
